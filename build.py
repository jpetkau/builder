import subprocess

"""
meta-terminology:
- Mostly I'll use "function" to mean "pure function" as viewed from inside
  the system, and "method" to mean "any python method which may do grungy
  things to maintain the illusion." "Command" means some other process which
  we exec.

output_dir:
- needs a hash of current fn args
- uses implicit stack

files for which we don't care about the name:
- nearly equivalent to blobs
- have a call: "filename_for_bytes" which gives a filename to some bytes
  - may be an actual file on disk or some pipe magic
- output from subprocess etc. should be an object like this

    StaticFile(bytes) StaticFile(fs, path)
"""

class Path:
  """
  Path represents a file or a directory for which the name or
  location may be significant.

  E.g. if I run `python myscript.py`, and `myscript` expects to find
  `a.txt` and `b.txt` in its same directory, then all three have
  significant locations.

  Wheras if I run `cat file1 file2 > file3`, the three files could
  be anywhere and it wouldn't matter as long as the contents were
  the same. These can therefore be passed as Blob instead of Path,
  so the names are not considered for hashing.
  """

class Blob:
  """
  Logical equivalent to bytes(), but used as a filesystem file
  """
  def __init__(self, *, ospath):
    self._ospath = ospath
    self._hash = None

  def __bhash__(self):
    # content hash
    with open(self._ospath, "rb") as f:
      
    return fs.HashBytes(self._ospath)

  def path(self):
    """gets an ephemeral path for a blob.

    Blobs with the same contents will always return the same paths.
    """
    if not self._path:
      path = implicit.gen_root_dir / hash(self)
      

  def __len__(self):
    if self._len:
      return self._len
    if self._bytes:
      return len(self.bytes)
    return os.path.

@memo
def run_tool(*args):
  odir = fs.make_output_dir()
  stdout_path = odir / "stdout"
  stderr_path = odir / "stderr"
  with stdout_path.open("wb") as stdout, stderr_path.open("wb") as stderr:
    p = subprocess.run(args,
      stdin=subprocess.DEVNULL,
      stdout=stdout,
      stderr=stderr,
      cwd=odir,
      check=True)
  return util.Struct(
    path=odir,
    stdout=stdout_path.blob()
    stderr=stderr_path.blob())

@memo
def cat(*files, fs):
    paths = fs.resolve_input_paths(files)
    return run_tool("/bin/cat", *paths).stdout

# args can be:
# - literal strings (for flags etc., not paths)
# - source paths
# - output paths

class StrArg(NamedTuple):
  value: str

  def hash(self):
    yield "s"
    yield self.str

# Problem: do we care about the path or filename,
# or just the contents?
#
# C++: filename shows up in __file__, we might care about that
# if path changes to another dir, quote-includes resolve differently,
# that's important!
class SourceRef(NamedTuple):
  root_relative_path: str

  def hash(self, hasher):
    return hasher("sf", self.root_relative_path, fs.input_content_hash(self.file))

class GeneratedFile:
  """
  Represents a single file generated by some other step
  """
  path: str
  

class TargetOutputFile(NamedTuple):
  """
  Represents a single output file from another target
  Which do we hash on?
  - That target's inputs?
  - Or binary content hash?

  Definitely need to do the inputs. Content hash sometimes
  also helps, not always.
  """
  target: Any

  def hash(self):

class InstalledTool:
  """Represents some preinstalled executable tool, like gcc.

  Assumes we can't tell what other crud it might depend on, so
  we have to trust whoever instanstiates this class.
  """
  def __init__(self, path, other_deps):
    self.__hash_value__ = hash(path, *other_deps)
    self.path = path

  def __vhash__(self):
    return 

  @memo
  def __call__(self, args):
    # 

@memoize
def run_tool(h, args, other_deps, stdin=None):
  strargs = fs.arg_to_str(h, arg) for arg in args
  if stdin is None:
    stdin_path=fs.null_input_path
  else:
    stdin_path=fs.input_path(stdin)

  stdout_path=fs.output_path(h, "stdout")
  stderr_path=fs.output_path(h, "stderr")
  outdir=fs.make_output_dir(h)
  with open(stdin_path, "rb") as fin, open(stdout_path, "wb") as fout, open(stderr_path, "wb") as ferr:
    p = subprocess.run(strargs, stdin=fin, stdout=fout, stderr=ferr, cwd=outdir)
